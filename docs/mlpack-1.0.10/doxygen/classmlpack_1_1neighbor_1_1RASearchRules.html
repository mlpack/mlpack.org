<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MLPACK: mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacemlpack.html">mlpack</a>      </li>
      <li><a class="el" href="namespacemlpack_1_1neighbor.html">neighbor</a>      </li>
      <li><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="mlpack::neighbor::RASearchRules" -->
<p><a href="classmlpack_1_1neighbor_1_1RASearchRules-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">neighbor::NeighborSearchTraversalInfo</a><br class="typebreak"/>
&lt; TreeType &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aad508670c1f95033543b9dacdc89dc43">TraversalInfoType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a60fb8ffad13a5f76f95150a30f3a77e1">RASearchRules</a> (const arma::mat &amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ad68fb2a917750a04891ab7038fe14c1c">referenceSet</a>, const arma::mat &amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a45f4b523edeaec45c008c6afdafe0b15">querySet</a>, arma::Mat&lt; size_t &gt; &amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a80486b1fbf6eaffee9515cd1e65a71ce">neighbors</a>, arma::mat &amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ad9e4dc6891f2c2e499165e80585d54e0">distances</a>, MetricType &amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a39a48dc48445713707688480328cc7d0">metric</a>, const double tau=5, const double alpha=0.95, const bool naive=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aff207b85035a96adaa2ddd9e5c2b1eb8">sampleAtLeaves</a>=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aee9f688b1e22ffc6152f07598227f1af">firstLeafExact</a>=false, const size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a3f9d1c8e6b9339a68b559b725a914c52">singleSampleLimit</a>=20)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a04043cd033205b49c5c8bed14ed003ef">BaseCase</a> (const size_t queryIndex, const size_t referenceIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ac330f6e8079d98c995881219675d2199">NumDistComputations</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a345f53d0e65721c9d14cb13772872400">NumEffectiveSamples</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab1b7e932026c8da2ebe1a0850ef74e1b">Rescore</a> (TreeType &amp;queryNode, TreeType &amp;referenceNode, const double oldScore)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-evaluate the score for recursion order.  <a href="#ab1b7e932026c8da2ebe1a0850ef74e1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a0ef2f7df444c8e48566ee9d9f2eee04a">Rescore</a> (const size_t queryIndex, TreeType &amp;referenceNode, const double oldScore)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-evaluate the score for recursion order.  <a href="#a0ef2f7df444c8e48566ee9d9f2eee04a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a43c10090e916f7d397aad449ad05735f">Score</a> (TreeType &amp;queryNode, TreeType &amp;referenceNode, const double baseCaseResult)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the score for recursion order, passing the base case result (in the situation where it may be needed to calculate the recursion order).  <a href="#a43c10090e916f7d397aad449ad05735f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a67cc346d0a0372bf508f13a1bc90fba1">Score</a> (TreeType &amp;queryNode, TreeType &amp;referenceNode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the score for recursion order.  <a href="#a67cc346d0a0372bf508f13a1bc90fba1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a99bf0fe9e89f02c6d528e8336412b586">Score</a> (const size_t queryIndex, TreeType &amp;referenceNode, const double baseCaseResult)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the score for recursion order.  <a href="#a99bf0fe9e89f02c6d528e8336412b586"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aecec6c616cb42dd9213b7fc28b42e59b">Score</a> (const size_t queryIndex, TreeType &amp;referenceNode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the score for recursion order.  <a href="#aecec6c616cb42dd9213b7fc28b42e59b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">TraversalInfoType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aa14107e65fee40320ef82ffccbc10875">TraversalInfo</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">TraversalInfoType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aebf9794fc98aa1f8ea0acd81233a8f80">TraversalInfo</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a80cc71b34aa369704f7307adcac21b87">InsertNeighbor</a> (const size_t queryIndex, const size_t pos, const size_t neighbor, const double distance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a point into the neighbors and distances matrices; this is a helper function.  <a href="#a80cc71b34aa369704f7307adcac21b87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a21c70d03f7e018609394fe45e44acce5">MinimumSamplesReqd</a> (const size_t n, const size_t k, const double tau, const double alpha) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the minimum number of samples required to guarantee the given rank-approximation and success probability.  <a href="#a21c70d03f7e018609394fe45e44acce5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aa7be3b585c38df5ebfb23a2f2538fe05">ObtainDistinctSamples</a> (const size_t numSamples, const size_t rangeUpperBound, arma::uvec &amp;distinctSamples) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pick up desired number of samples (with replacement) from a given range of integers so that only the distinct samples are returned from the range [0 - specified upper bound).  <a href="#aa7be3b585c38df5ebfb23a2f2538fe05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a318f1323e382838e8189ca43ddb5f246">Score</a> (const size_t queryIndex, TreeType &amp;referenceNode, const double distance, const double bestDistance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform actual scoring for single-tree case.  <a href="#a318f1323e382838e8189ca43ddb5f246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab1a37212480c77803637ee31432251ec">Score</a> (TreeType &amp;queryNode, TreeType &amp;referenceNode, const double distance, const double bestDistance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform actual scoring for dual-tree case.  <a href="#ab1a37212480c77803637ee31432251ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a68657de8ba2bd6aff081d9d713ca0fec">SuccessProbability</a> (const size_t n, const size_t k, const size_t m, const size_t t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the success probability of obtaining 'k'-neighbors from a set of size 'n' within the top 't' neighbors if 'm' samples are made.  <a href="#a68657de8ba2bd6aff081d9d713ca0fec"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ad9e4dc6891f2c2e499165e80585d54e0">distances</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The matrix the resultant neighbor distances should be stored in.  <a href="#ad9e4dc6891f2c2e499165e80585d54e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aee9f688b1e22ffc6152f07598227f1af">firstLeafExact</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether to do exact computation on the first leaf before any sampling.  <a href="#aee9f688b1e22ffc6152f07598227f1af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MetricType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a39a48dc48445713707688480328cc7d0">metric</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The instantiated metric.  <a href="#a39a48dc48445713707688480328cc7d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::Mat&lt; size_t &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a80486b1fbf6eaffee9515cd1e65a71ce">neighbors</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The matrix the resultant neighbor indices should be stored in.  <a href="#a80486b1fbf6eaffee9515cd1e65a71ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a4f344e7cbe096b65a5630c44fb853bcb">numDistComputations</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::Col&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a743d34199cea283a411b4273625f45e3">numSamplesMade</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of samples made for every query.  <a href="#a743d34199cea283a411b4273625f45e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aeb00aa72b98e76453fa7905d387a25ca">numSamplesReqd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The minimum number of samples required per query.  <a href="#aeb00aa72b98e76453fa7905d387a25ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const arma::mat &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a45f4b523edeaec45c008c6afdafe0b15">querySet</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The query set.  <a href="#a45f4b523edeaec45c008c6afdafe0b15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const arma::mat &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ad68fb2a917750a04891ab7038fe14c1c">referenceSet</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The reference set.  <a href="#ad68fb2a917750a04891ab7038fe14c1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aff207b85035a96adaa2ddd9e5c2b1eb8">sampleAtLeaves</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether to sample at leaves or just use all of it.  <a href="#aff207b85035a96adaa2ddd9e5c2b1eb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a80c829f23240a95f839feec344e6bdd4">samplingRatio</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The sampling ratio.  <a href="#a80c829f23240a95f839feec344e6bdd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a3f9d1c8e6b9339a68b559b725a914c52">singleSampleLimit</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The limit on the largest node that can be approximated by sampling.  <a href="#a3f9d1c8e6b9339a68b559b725a914c52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">TraversalInfoType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a39c0c64915315f578cc4c7b695cdcd2b">traversalInfo</a></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a67734413883d770268f88438780c4b7c">RASearch&lt; SortPolicy, MetricType, TreeType &gt;</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename SortPolicy, typename MetricType, typename TreeType&gt;<br/>
 class mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;</h3>


<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00034">34</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aad508670c1f95033543b9dacdc89dc43"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::TraversalInfoType" ref="aad508670c1f95033543b9dacdc89dc43" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">neighbor::NeighborSearchTraversalInfo</a>&lt;TreeType&gt; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">TraversalInfoType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00205">205</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a60fb8ffad13a5f76f95150a30f3a77e1"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::RASearchRules" ref="a60fb8ffad13a5f76f95150a30f3a77e1" args="(const arma::mat &amp;referenceSet, const arma::mat &amp;querySet, arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances, MetricType &amp;metric, const double tau=5, const double alpha=0.95, const bool naive=false, const bool sampleAtLeaves=false, const bool firstLeafExact=false, const size_t singleSampleLimit=20)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">RASearchRules</a> </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&nbsp;</td>
          <td class="paramname"> <em>querySet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&nbsp;</td>
          <td class="paramname"> <em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetricType &amp;&nbsp;</td>
          <td class="paramname"> <em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tau</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>sampleAtLeaves</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>firstLeafExact</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>singleSampleLimit</em> = <code>20</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a04043cd033205b49c5c8bed14ed003ef"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::BaseCase" ref="a04043cd033205b49c5c8bed14ed003ef" args="(const size_t queryIndex, const size_t referenceIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::BaseCase </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>referenceIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a80cc71b34aa369704f7307adcac21b87"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::InsertNeighbor" ref="a80cc71b34aa369704f7307adcac21b87" args="(const size_t queryIndex, const size_t pos, const size_t neighbor, const double distance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::InsertNeighbor </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>neighbor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>distance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a point into the neighbors and distances matrices; this is a helper function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queryIndex</em>&nbsp;</td><td>Index of point whose neighbors we are inserting into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in list to insert into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>neighbor</em>&nbsp;</td><td>Index of reference point which is being inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>Distance from query point to reference point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21c70d03f7e018609394fe45e44acce5"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::MinimumSamplesReqd" ref="a21c70d03f7e018609394fe45e44acce5" args="(const size_t n, const size_t k, const double tau, const double alpha) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::MinimumSamplesReqd </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the minimum number of samples required to guarantee the given rank-approximation and success probability. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Size of the set to be sampled from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The number of neighbors required within the rank-approximation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>The rank-approximation in percentile of the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The success probability desired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac330f6e8079d98c995881219675d2199"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::NumDistComputations" ref="ac330f6e8079d98c995881219675d2199" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::NumDistComputations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00196">196</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

<p>References <a class="el" href="ra__search__rules_8hpp_source.html#l00245">mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::numDistComputations</a>.</p>

</div>
</div>
<a class="anchor" id="a345f53d0e65721c9d14cb13772872400"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::NumEffectiveSamples" ref="a345f53d0e65721c9d14cb13772872400" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::NumEffectiveSamples </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00197">197</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

<p>References <a class="el" href="ra__search__rules_8hpp_source.html#l00239">mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::numSamplesMade</a>.</p>

</div>
</div>
<a class="anchor" id="aa7be3b585c38df5ebfb23a2f2538fe05"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::ObtainDistinctSamples" ref="aa7be3b585c38df5ebfb23a2f2538fe05" args="(const size_t numSamples, const size_t rangeUpperBound, arma::uvec &amp;distinctSamples) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::ObtainDistinctSamples </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>numSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>rangeUpperBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::uvec &amp;&nbsp;</td>
          <td class="paramname"> <em>distinctSamples</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pick up desired number of samples (with replacement) from a given range of integers so that only the distinct samples are returned from the range [0 - specified upper bound). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numSamples</em>&nbsp;</td><td>Number of random samples. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rangeUpperBound</em>&nbsp;</td><td>The upper bound on the range of integers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>distinctSamples</em>&nbsp;</td><td>The list of the distinct samples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ef2f7df444c8e48566ee9d9f2eee04a"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::Rescore" ref="a0ef2f7df444c8e48566ee9d9f2eee04a" args="(const size_t queryIndex, TreeType &amp;referenceNode, const double oldScore)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::Rescore </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>oldScore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-evaluate the score for recursion order. </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned). This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning. So the old score is checked against the new pruning bound.</p>
<p>For rank-approximation, it also checks if the number of samples left for a query to satisfy the rank constraint is small enough at this point of the algorithm, then this node is approximated by sampling and given a new score of 'DBL_MAX'.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queryIndex</em>&nbsp;</td><td>Index of query point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>referenceNode</em>&nbsp;</td><td>Candidate node to be recursed into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldScore</em>&nbsp;</td><td>Old score produced by <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aecec6c616cb42dd9213b7fc28b42e59b" title="Get the score for recursion order.">Score()</a> (or <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a0ef2f7df444c8e48566ee9d9f2eee04a" title="Re-evaluate the score for recursion order.">Rescore()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1b7e932026c8da2ebe1a0850ef74e1b"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::Rescore" ref="ab1b7e932026c8da2ebe1a0850ef74e1b" args="(TreeType &amp;queryNode, TreeType &amp;referenceNode, const double oldScore)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::Rescore </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>queryNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>oldScore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-evaluate the score for recursion order. </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned). This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning. So the old score is checked against the new pruning bound.</p>
<p>For the rank-approximation, we check if the referenceNode can be approximated by sampling. If it can be, enough samples are made for every query in the queryNode. No further query-tree traversal is performed.</p>
<p>The 'NumSamplesMade' query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queryNode</em>&nbsp;</td><td>Candidate query node to recurse into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>referenceNode</em>&nbsp;</td><td>Candidate reference node to recurse into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldScore</em>&nbsp;</td><td>Old score produced by Socre() (or <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a0ef2f7df444c8e48566ee9d9f2eee04a" title="Re-evaluate the score for recursion order.">Rescore()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43c10090e916f7d397aad449ad05735f"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::Score" ref="a43c10090e916f7d397aad449ad05735f" args="(TreeType &amp;queryNode, TreeType &amp;referenceNode, const double baseCaseResult)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::Score </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>queryNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>baseCaseResult</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the score for recursion order, passing the base case result (in the situation where it may be needed to calculate the recursion order). </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned).</p>
<p>For the rank-approximation, we check if the referenceNode can be approximated by sampling. If it can be, enough samples are made for every query in the queryNode. No further query-tree traversal is performed.</p>
<p>The 'NumSamplesMade' query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queryNode</em>&nbsp;</td><td>Candidate query node to recurse into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>referenceNode</em>&nbsp;</td><td>Candidate reference node to recurse into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseCaseResult</em>&nbsp;</td><td>Result of BaseCase(queryIndex, referenceNode). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecec6c616cb42dd9213b7fc28b42e59b"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::Score" ref="aecec6c616cb42dd9213b7fc28b42e59b" args="(const size_t queryIndex, TreeType &amp;referenceNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::Score </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the score for recursion order. </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned).</p>
<p>For rank-approximation, the scoring function first checks if pruning by distance is possible. If yes, then the node is given the score of 'DBL_MAX' and the expected number of samples from that node are added to the number of samples made for the query.</p>
<p>If no, then the function tries to see if the node can be pruned by approximation. If number of samples required from this node is small enough, then that number of samples are acquired from this node and the score is set to be 'DBL_MAX'.</p>
<p>If the pruning by approximation is not possible either, the algorithm continues with the usual tree-traversal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queryIndex</em>&nbsp;</td><td>Index of query point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>referenceNode</em>&nbsp;</td><td>Candidate node to be recursed into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99bf0fe9e89f02c6d528e8336412b586"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::Score" ref="a99bf0fe9e89f02c6d528e8336412b586" args="(const size_t queryIndex, TreeType &amp;referenceNode, const double baseCaseResult)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::Score </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>baseCaseResult</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the score for recursion order. </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned).</p>
<p>For rank-approximation, the scoring function first checks if pruning by distance is possible. If yes, then the node is given the score of 'DBL_MAX' and the expected number of samples from that node are added to the number of samples made for the query.</p>
<p>If no, then the function tries to see if the node can be pruned by approximation. If number of samples required from this node is small enough, then that number of samples are acquired from this node and the score is set to be 'DBL_MAX'.</p>
<p>If the pruning by approximation is not possible either, the algorithm continues with the usual tree-traversal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queryIndex</em>&nbsp;</td><td>Index of query point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>referenceNode</em>&nbsp;</td><td>Candidate node to be recursed into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseCaseResult</em>&nbsp;</td><td>Result of BaseCase(queryIndex, referenceNode). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a318f1323e382838e8189ca43ddb5f246"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::Score" ref="a318f1323e382838e8189ca43ddb5f246" args="(const size_t queryIndex, TreeType &amp;referenceNode, const double distance, const double bestDistance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::Score </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>bestDistance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform actual scoring for single-tree case. </p>

</div>
</div>
<a class="anchor" id="a67cc346d0a0372bf508f13a1bc90fba1"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::Score" ref="a67cc346d0a0372bf508f13a1bc90fba1" args="(TreeType &amp;queryNode, TreeType &amp;referenceNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::Score </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>queryNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the score for recursion order. </p>
<p>A low score indicates priority for recursionm while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned).</p>
<p>For the rank-approximation, we check if the referenceNode can be approximated by sampling. If it can be, enough samples are made for every query in the queryNode. No further query-tree traversal is performed.</p>
<p>The 'NumSamplesMade' query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queryNode</em>&nbsp;</td><td>Candidate query node to recurse into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>referenceNode</em>&nbsp;</td><td>Candidate reference node to recurse into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1a37212480c77803637ee31432251ec"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::Score" ref="ab1a37212480c77803637ee31432251ec" args="(TreeType &amp;queryNode, TreeType &amp;referenceNode, const double distance, const double bestDistance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::Score </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>queryNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&nbsp;</td>
          <td class="paramname"> <em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>bestDistance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform actual scoring for dual-tree case. </p>

</div>
</div>
<a class="anchor" id="a68657de8ba2bd6aff081d9d713ca0fec"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::SuccessProbability" ref="a68657de8ba2bd6aff081d9d713ca0fec" args="(const size_t n, const size_t k, const size_t m, const size_t t) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::SuccessProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the success probability of obtaining 'k'-neighbors from a set of size 'n' within the top 't' neighbors if 'm' samples are made. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Size of the set being sampled from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The number of neighbors required within the rank-approximation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The number of random samples. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The desired rank-approximation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa14107e65fee40320ef82ffccbc10875"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::TraversalInfo" ref="aa14107e65fee40320ef82ffccbc10875" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">TraversalInfoType</a>&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classTraversalInfo.html">TraversalInfo</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00207">207</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

<p>References <a class="el" href="ra__search__rules_8hpp_source.html#l00247">mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::traversalInfo</a>.</p>

</div>
</div>
<a class="anchor" id="aebf9794fc98aa1f8ea0acd81233a8f80"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::TraversalInfo" ref="aebf9794fc98aa1f8ea0acd81233a8f80" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">TraversalInfoType</a>&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classTraversalInfo.html">TraversalInfo</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00208">208</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

<p>References <a class="el" href="ra__search__rules_8hpp_source.html#l00247">mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::traversalInfo</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a67734413883d770268f88438780c4b7c"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::RASearch&lt; SortPolicy, MetricType, TreeType &gt;" ref="a67734413883d770268f88438780c4b7c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classRASearch.html">RASearch</a>&lt; SortPolicy, MetricType, TreeType &gt;<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00323">323</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad9e4dc6891f2c2e499165e80585d54e0"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::distances" ref="ad9e4dc6891f2c2e499165e80585d54e0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::mat&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ad9e4dc6891f2c2e499165e80585d54e0">distances</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The matrix the resultant neighbor distances should be stored in. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00221">221</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee9f688b1e22ffc6152f07598227f1af"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::firstLeafExact" ref="aee9f688b1e22ffc6152f07598227f1af" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aee9f688b1e22ffc6152f07598227f1af">firstLeafExact</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether to do exact computation on the first leaf before any sampling. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00230">230</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39a48dc48445713707688480328cc7d0"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::metric" ref="a39a48dc48445713707688480328cc7d0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MetricType&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a39a48dc48445713707688480328cc7d0">metric</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The instantiated metric. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00224">224</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80486b1fbf6eaffee9515cd1e65a71ce"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::neighbors" ref="a80486b1fbf6eaffee9515cd1e65a71ce" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::Mat&lt;size_t&gt;&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a80486b1fbf6eaffee9515cd1e65a71ce">neighbors</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The matrix the resultant neighbor indices should be stored in. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00218">218</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f344e7cbe096b65a5630c44fb853bcb"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::numDistComputations" ref="a4f344e7cbe096b65a5630c44fb853bcb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a4f344e7cbe096b65a5630c44fb853bcb">numDistComputations</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00245">245</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search__rules_8hpp_source.html#l00196">mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::NumDistComputations()</a>.</p>

</div>
</div>
<a class="anchor" id="a743d34199cea283a411b4273625f45e3"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::numSamplesMade" ref="a743d34199cea283a411b4273625f45e3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::Col&lt;size_t&gt; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a743d34199cea283a411b4273625f45e3">numSamplesMade</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of samples made for every query. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00239">239</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search__rules_8hpp_source.html#l00197">mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::NumEffectiveSamples()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb00aa72b98e76453fa7905d387a25ca"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::numSamplesReqd" ref="aeb00aa72b98e76453fa7905d387a25ca" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aeb00aa72b98e76453fa7905d387a25ca">numSamplesReqd</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The minimum number of samples required per query. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00236">236</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45f4b523edeaec45c008c6afdafe0b15"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::querySet" ref="a45f4b523edeaec45c008c6afdafe0b15" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const arma::mat&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a45f4b523edeaec45c008c6afdafe0b15">querySet</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The query set. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00215">215</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad68fb2a917750a04891ab7038fe14c1c"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::referenceSet" ref="ad68fb2a917750a04891ab7038fe14c1c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const arma::mat&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ad68fb2a917750a04891ab7038fe14c1c">referenceSet</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The reference set. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00212">212</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff207b85035a96adaa2ddd9e5c2b1eb8"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::sampleAtLeaves" ref="aff207b85035a96adaa2ddd9e5c2b1eb8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aff207b85035a96adaa2ddd9e5c2b1eb8">sampleAtLeaves</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether to sample at leaves or just use all of it. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00227">227</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80c829f23240a95f839feec344e6bdd4"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::samplingRatio" ref="a80c829f23240a95f839feec344e6bdd4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a80c829f23240a95f839feec344e6bdd4">samplingRatio</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sampling ratio. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00242">242</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f9d1c8e6b9339a68b559b725a914c52"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::singleSampleLimit" ref="a3f9d1c8e6b9339a68b559b725a914c52" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a3f9d1c8e6b9339a68b559b725a914c52">singleSampleLimit</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The limit on the largest node that can be approximated by sampling. </p>

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00233">233</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39c0c64915315f578cc4c7b695cdcd2b"></a><!-- doxytag: member="mlpack::neighbor::RASearchRules::traversalInfo" ref="a39c0c64915315f578cc4c7b695cdcd2b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy , typename MetricType , typename TreeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearchTraversalInfo.html">TraversalInfoType</a> <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">mlpack::neighbor::RASearchRules</a>&lt; SortPolicy, MetricType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a39c0c64915315f578cc4c7b695cdcd2b">traversalInfo</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00247">247</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search__rules_8hpp_source.html#l00207">mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::TraversalInfo()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mlpack/methods/rann/<a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Aug 19 2015 16:52:15 for MLPACK by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
